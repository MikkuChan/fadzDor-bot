// handlers/adminCommands.js
// Complete Admin Commands untuk fadzDor Bot
// Berisi semua fungsi admin seperti statistik, manajemen user, broadcast, dll

const db = require('../utils/database');
const config = require('../config/config');
const hesdaApi = require('../services/hesdaApi');
const { logAdminAction, logSystemError } = require('../utils/logger');

class AdminCommands {
  // Statistik sistem lengkap
  static async getSystemStats(sock, sender) {
    try {
      await sock.sendMessage(sender, { text: 'üìä Mengambil statistik sistem...' });
      
      const users = await db.getAllUsers();
      const userCount = Object.keys(users).length;
      
      let totalSaldo = 0;
      let activeUsers = 0;
      let dormantUsers = 0;
      const today = new Date();
      const sevenDaysAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
      const thirtyDaysAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
      
      // Analisis user
      for (const user of Object.values(users)) {
        totalSaldo += user.saldo || 0;
        const lastActivity = new Date(user.lastActivity || user.registeredAt);
        
        if (lastActivity > sevenDaysAgo) {
          activeUsers++;
        } else if (lastActivity < thirtyDaysAgo) {
          dormantUsers++;
        }
      }

      // Get recent transactions
      const transactions = await db.readFile('./data/transactions.json');
      const allTransactions = Object.values(transactions);
      
      // Filter transaksi
      const todayTransactions = allTransactions.filter(tx => {
        const txDate = new Date(tx.createdAt);
        return txDate.toDateString() === today.toDateString();
      });

      const weekTransactions = allTransactions.filter(tx => {
        const txDate = new Date(tx.createdAt);
        return txDate > sevenDaysAgo;
      });

      const monthTransactions = allTransactions.filter(tx => {
        const txDate = new Date(tx.createdAt);
        return txDate > thirtyDaysAgo;
      });

      const successTransactions = allTransactions.filter(tx => tx.status === 'SUCCESS');
      const failedTransactions = allTransactions.filter(tx => tx.status === 'FAILED');
      const pendingTransactions = allTransactions.filter(tx => tx.status === 'PROCESSING');

      // Hitung revenue dan profit
      let totalRevenue = 0;
      let totalProfit = 0;
      let todayRevenue = 0;
      let weekRevenue = 0;
      let monthRevenue = 0;

      successTransactions.forEach(tx => {
        const amount = tx.amount || 0;
        const cost = tx.cost || 0;
        totalRevenue += amount;
        totalProfit += (amount - cost);
        
        const txDate = new Date(tx.createdAt);
        if (txDate.toDateString() === today.toDateString()) {
          todayRevenue += amount;
        }
        if (txDate > sevenDaysAgo) {
          weekRevenue += amount;
        }
        if (txDate > thirtyDaysAgo) {
          monthRevenue += amount;
        }
      });

      // Hitung success rate
      const successRate = allTransactions.length > 0 
        ? ((successTransactions.length / allTransactions.length) * 100).toFixed(1)
        : 0;

      // Package popularity
      const packageStats = {};
      successTransactions.forEach(tx => {
        const packageName = tx.packageName || 'Unknown';
        packageStats[packageName] = (packageStats[packageName] || 0) + 1;
      });

      const topPackages = Object.entries(packageStats)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 3);

      const message = `
üìä *Statistik Sistem fadzDor*

üë• *Users (${userCount} total):*
‚Ä¢ User aktif (7 hari): ${activeUsers}
‚Ä¢ User tidak aktif (30+ hari): ${dormantUsers}
‚Ä¢ Total saldo tersimpan: Rp. ${totalSaldo.toLocaleString('id-ID')}

üí∞ *Transaksi:*
‚Ä¢ Total transaksi: ${allTransactions.length}
‚Ä¢ ‚úÖ Sukses: ${successTransactions.length} (${successRate}%)
‚Ä¢ ‚ùå Gagal: ${failedTransactions.length}
‚Ä¢ ‚è≥ Pending: ${pendingTransactions.length}

üìÖ *Periode:*
‚Ä¢ Hari ini: ${todayTransactions.length} (Rp.${todayRevenue.toLocaleString('id-ID')})
‚Ä¢ 7 hari: ${weekTransactions.length} (Rp.${weekRevenue.toLocaleString('id-ID')})
‚Ä¢ 30 hari: ${monthTransactions.length} (Rp.${monthRevenue.toLocaleString('id-ID')})

üíµ *Financial:*
‚Ä¢ Total revenue: Rp. ${totalRevenue.toLocaleString('id-ID')}
‚Ä¢ Total profit: Rp. ${totalProfit.toLocaleString('id-ID')}
‚Ä¢ Margin: ${totalRevenue > 0 ? ((totalProfit/totalRevenue)*100).toFixed(1) : 0}%

üî• *Paket Terpopuler:*
${topPackages.map((([name, count], index) => `${index + 1}. ${name}: ${count}x`)).join('\n')}

üìÖ *Update:* ${new Date().toLocaleString('id-ID')}
      `;

      await sock.sendMessage(sender, { text: message });
      logAdminAction('VIEW_STATS', sender);
      
    } catch (error) {
      logSystemError(error, 'Getting system stats');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal mengambil statistik sistem. Silakan coba lagi.' 
      });
    }
  }

  // Lihat user dengan saldo tertinggi
  static async getTopUsers(sock, sender, limit = 10) {
    try {
      const users = await db.getAllUsers();
      const sortedUsers = Object.values(users)
        .sort((a, b) => (b.saldo || 0) - (a.saldo || 0))
        .slice(0, limit);

      if (sortedUsers.length === 0) {
        await sock.sendMessage(sender, { 
          text: 'üìä Belum ada user yang terdaftar.' 
        });
        return;
      }

      let message = `üëë *Top ${limit} User (Saldo Tertinggi)*\n\n`;
      
      sortedUsers.forEach((user, index) => {
        const phone = user.phoneNumber.replace('62', '+62 ').replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
        const saldo = user.saldo || 0;
        const totalTx = user.totalTransaksi || 0;
        const lastActivity = new Date(user.lastActivity || user.registeredAt).toLocaleDateString('id-ID');
        
        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
        
        message += `${medal} ${phone}\n`;
        message += `   üí∞ Saldo: Rp. ${saldo.toLocaleString('id-ID')}\n`;
        message += `   üìä Transaksi: ${totalTx}x\n`;
        message += `   üïê Terakhir: ${lastActivity}\n\n`;
      });

      // Summary
      const totalUsers = Object.keys(users).length;
      const totalSaldo = Object.values(users).reduce((sum, user) => sum + (user.saldo || 0), 0);
      const avgSaldo = totalUsers > 0 ? Math.round(totalSaldo / totalUsers) : 0;

      message += `üìä *Summary:*\n`;
      message += `‚Ä¢ Total users: ${totalUsers}\n`;
      message += `‚Ä¢ Total saldo: Rp. ${totalSaldo.toLocaleString('id-ID')}\n`;
      message += `‚Ä¢ Rata-rata saldo: Rp. ${avgSaldo.toLocaleString('id-ID')}`;

      await sock.sendMessage(sender, { text: message });
      logAdminAction('VIEW_TOP_USERS', sender, '', `Limit: ${limit}`);
      
    } catch (error) {
      logSystemError(error, 'Getting top users');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal mengambil data top users.' 
      });
    }
  }

  // Cari user berdasarkan nomor
  static async searchUser(sock, sender, searchQuery) {
    try {
      if (!searchQuery || searchQuery.length < 3) {
        await sock.sendMessage(sender, { 
          text: '‚ùå Query pencarian terlalu pendek. Minimal 3 karakter.' 
        });
        return;
      }

      const users = await db.getAllUsers();
      const results = [];
      const cleanQuery = searchQuery.replace(/\D/g, ''); // Remove non-digits

      for (const [phone, userData] of Object.entries(users)) {
        if (phone.includes(cleanQuery)) {
          results.push({ phone, ...userData });
        }
      }

      if (results.length === 0) {
        await sock.sendMessage(sender, { 
          text: `üîç *Pencarian User*\n\nTidak ditemukan user dengan nomor: ${searchQuery}\n\nPastikan nomor yang dicari sudah pernah menggunakan bot.` 
        });
        return;
      }

      let message = `üîç *Hasil Pencarian User*\nQuery: "${searchQuery}"\n\n`;
      
      results.slice(0, 5).forEach((user, index) => { // Limit 5 results
        const phone = user.phone.replace('62', '+62 ').replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
        const saldo = user.saldo || 0;
        const totalTx = user.totalTransaksi || 0;
        const registered = new Date(user.registeredAt).toLocaleDateString('id-ID');
        const lastActivity = new Date(user.lastActivity || user.registeredAt).toLocaleDateString('id-ID');
        
        // Calculate activity status
        const daysSinceLastActivity = Math.floor((Date.now() - new Date(user.lastActivity || user.registeredAt)) / (1000 * 60 * 60 * 24));
        const activityStatus = daysSinceLastActivity <= 7 ? 'üü¢ Aktif' : 
                              daysSinceLastActivity <= 30 ? 'üü° Kurang Aktif' : 'üî¥ Tidak Aktif';

        message += `${index + 1}. ${phone}\n`;
        message += `   üí∞ Saldo: Rp. ${saldo.toLocaleString('id-ID')}\n`;
        message += `   üìä Transaksi: ${totalTx}x\n`;
        message += `   üìÖ Daftar: ${registered}\n`;
        message += `   üïê Aktif: ${lastActivity}\n`;
        message += `   ${activityStatus}\n\n`;
      });

      if (results.length > 5) {
        message += `... dan ${results.length - 5} user lainnya`;
      }

      await sock.sendMessage(sender, { text: message });
      logAdminAction('SEARCH_USER', sender, searchQuery, `Found: ${results.length}`);
      
    } catch (error) {
      logSystemError(error, 'Searching user');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal mencari user.' 
      });
    }
  }

  // Broadcast message ke semua user
  static async broadcastMessage(sock, sender, message) {
    try {
      if (!message || message.trim().length === 0) {
        await sock.sendMessage(sender, { 
          text: '‚ùå Pesan broadcast tidak boleh kosong.' 
        });
        return;
      }

      if (message.length > 1000) {
        await sock.sendMessage(sender, { 
          text: '‚ùå Pesan terlalu panjang. Maksimal 1000 karakter.' 
        });
        return;
      }

      const users = await db.getAllUsers();
      const userNumbers = Object.keys(users);
      
      if (userNumbers.length === 0) {
        await sock.sendMessage(sender, { 
          text: 'üì¢ Tidak ada user untuk di-broadcast.' 
        });
        return;
      }

      let successCount = 0;
      let failCount = 0;
      let skipCount = 0;

      await sock.sendMessage(sender, { 
        text: `üì¢ *Memulai broadcast...*\n\nTotal target: ${userNumbers.length} user\nEstimasi waktu: ${Math.ceil(userNumbers.length / 20)} menit\n\n‚è≥ Sedang memproses...` 
      });

      const broadcastMessage = `üì¢ *Pengumuman ${config.bot.name}*\n\n${message}\n\n_Pesan ini dikirim oleh admin pada ${new Date().toLocaleString('id-ID')}_`;

      // Send with rate limiting (max 20 per minute)
      for (let i = 0; i < userNumbers.length; i++) {
        const userNumber = userNumbers[i];
        
        try {
          // Skip admin numbers
          if (config.bot.adminNumbers.includes(userNumber) || userNumber === config.bot.ownerNumber) {
            skipCount++;
            continue;
          }

          await sock.sendMessage(userNumber, { text: broadcastMessage });
          successCount++;
          
          // Progress update every 50 messages
          if ((i + 1) % 50 === 0) {
            await sock.sendMessage(sender, { 
              text: `‚è≥ Progress: ${i + 1}/${userNumbers.length}\n‚úÖ Berhasil: ${successCount}\n‚ùå Gagal: ${failCount}` 
            });
          }
          
          // Rate limiting: 1 message per 3 seconds (20 per minute)
          await new Promise(resolve => setTimeout(resolve, 3000));
          
        } catch (error) {
          failCount++;
          logSystemError(error, `Broadcasting to ${userNumber}`);
          
          // Small delay even on error
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }

      const completionMessage = `‚úÖ *Broadcast Selesai*\n\nüìä **Hasil:**\n‚úÖ Berhasil: ${successCount}\n‚ùå Gagal: ${failCount}\n‚è≠Ô∏è Dilewati: ${skipCount}\nüéØ Total: ${userNumbers.length}\n\nüìà **Success Rate:** ${userNumbers.length > 0 ? Math.round((successCount / (userNumbers.length - skipCount)) * 100) : 0}%\n\nüìÖ Selesai: ${new Date().toLocaleString('id-ID')}`;

      await sock.sendMessage(sender, { text: completionMessage });

      logAdminAction('BROADCAST_MESSAGE', sender, '', 
        `Success: ${successCount}, Failed: ${failCount}, Skipped: ${skipCount}, Message: "${message.substring(0, 50)}..."`);
      
    } catch (error) {
      logSystemError(error, 'Broadcasting message');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal melakukan broadcast.' 
      });
    }
  }

  // Reset user saldo ke 0
  static async resetUserSaldo(sock, sender, targetNumber) {
    try {
      // Format phone number
      let formattedNumber = targetNumber.replace(/\D/g, '');
      if (formattedNumber.startsWith('0')) {
        formattedNumber = '62' + formattedNumber.substring(1);
      } else if (!formattedNumber.startsWith('62')) {
        formattedNumber = '62' + formattedNumber;
      }

      const user = await db.getUser(formattedNumber);
      if (!user) {
        await sock.sendMessage(sender, { 
          text: `‚ùå *User tidak ditemukan*\n\nNomor: ${targetNumber}\n\nPastikan nomor sudah pernah menggunakan bot.` 
        });
        return;
      }

      const oldSaldo = user.saldo || 0;
      
      if (oldSaldo === 0) {
        await sock.sendMessage(sender, { 
          text: `‚ÑπÔ∏è *Saldo sudah 0*\n\nUser: ${formattedNumber}\nSaldo saat ini: Rp. 0\n\nTidak perlu direset.` 
        });
        return;
      }

      await db.updateUserSaldo(formattedNumber, 0, 'set');

      const resetMessage = `‚úÖ *Saldo User Berhasil Direset*\n\nUser: ${formattedNumber}\nSaldo lama: Rp. ${oldSaldo.toLocaleString('id-ID')}\nSaldo baru: Rp. 0\n\nüìÖ ${new Date().toLocaleString('id-ID')}`;

      await sock.sendMessage(sender, { text: resetMessage });

      // Notifikasi ke user
      try {
        await sock.sendMessage(formattedNumber, { 
          text: `‚ö†Ô∏è *Saldo Direset*\n\nSaldo Anda telah direset ke Rp. 0 oleh admin.\n\nSaldo sebelumnya: Rp. ${oldSaldo.toLocaleString('id-ID')}\n\nJika ada pertanyaan, hubungi admin:\nwa.me/${config.bot.ownerNumber}` 
        });
      } catch (error) {
        await sock.sendMessage(sender, { 
          text: `‚ö†Ô∏è Reset berhasil, tapi gagal mengirim notifikasi ke user.` 
        });
      }

      logAdminAction('RESET_USER_SALDO', sender, formattedNumber, `Old saldo: ${oldSaldo}`);
      
    } catch (error) {
      logSystemError(error, 'Resetting user saldo');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal reset saldo user.' 
      });
    }
  }

  // Lihat transaksi pending
  static async getPendingTransactions(sock, sender) {
    try {
      const transactions = await db.readFile('./data/transactions.json');
      const pendingTx = Object.values(transactions)
        .filter(tx => tx.status === 'PROCESSING')
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      if (pendingTx.length === 0) {
        await sock.sendMessage(sender, { 
          text: '‚úÖ *Tidak ada transaksi pending*\n\nSemua transaksi sudah selesai diproses.' 
        });
        return;
      }

      let message = `‚è≥ *Transaksi Pending (${pendingTx.length})*\n\n`;
      
      pendingTx.slice(0, 10).forEach((tx, index) => {
        const time = new Date(tx.createdAt).toLocaleString('id-ID');
        const timeDiff = Math.floor((Date.now() - new Date(tx.createdAt)) / (1000 * 60)); // minutes
        
        message += `${index + 1}. *${tx.trxId}*\n`;
        message += `   üìû ${tx.targetNumber}\n`;
        message += `   üì¶ ${tx.packageName}\n`;
        message += `   üí∞ Rp. ${tx.amount.toLocaleString('id-ID')}\n`;
        message += `   üïê ${time} (${timeDiff} menit lalu)\n`;
        
        // Warning untuk transaksi lama
        if (timeDiff > 30) {
          message += `   ‚ö†Ô∏è Transaksi sudah ${timeDiff} menit (perlu dicek manual)\n`;
        }
        message += '\n';
      });

      if (pendingTx.length > 10) {
        message += `... dan ${pendingTx.length - 10} transaksi lainnya\n\n`;
      }

      message += `üí° *Tips:*\n`;
      message += `‚Ä¢ Gunakan ${config.bot.prefix}cektrx [ID] untuk cek status manual\n`;
      message += `‚Ä¢ Transaksi >30 menit sebaiknya dicek ke sistem Hesda`;

      await sock.sendMessage(sender, { text: message });
      logAdminAction('VIEW_PENDING_TX', sender, '', `Count: ${pendingTx.length}`);
      
    } catch (error) {
      logSystemError(error, 'Getting pending transactions');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal mengambil transaksi pending.' 
      });
    }
  }

  // Manual check status transaksi
  static async checkTransactionStatus(sock, sender, trxId) {
    try {
      if (!trxId || trxId.trim().length === 0) {
        await sock.sendMessage(sender, { 
          text: `‚ùå *ID Transaksi tidak valid*\n\nContoh penggunaan:\n${config.bot.prefix}cektrx TRX-1705745400000-abc123` 
        });
        return;
      }

      await sock.sendMessage(sender, { 
        text: `üîç Mengecek status transaksi...\nID: ${trxId}` 
      });

      const transaction = await db.getTransaction(trxId);
      if (!transaction) {
        await sock.sendMessage(sender, { 
          text: `‚ùå *Transaksi tidak ditemukan*\n\nID: ${trxId}\n\nPastikan ID transaksi benar.` 
        });
        return;
      }

      let message = `üîç *Status Transaksi*\n\n`;
      message += `üÜî ID: ${trxId}\n`;
      message += `üìû Target: ${transaction.targetNumber}\n`;
      message += `üì¶ Paket: ${transaction.packageName}\n`;
      message += `üí∞ Amount: Rp. ${transaction.amount.toLocaleString('id-ID')}\n`;
      message += `üìÖ Dibuat: ${new Date(transaction.createdAt).toLocaleString('id-ID')}\n`;
      
      if (transaction.updatedAt && transaction.updatedAt !== transaction.createdAt) {
        message += `üîÑ Update: ${new Date(transaction.updatedAt).toLocaleString('id-ID')}\n`;
      }

      const statusIcon = transaction.status === 'SUCCESS' ? '‚úÖ' : 
                        transaction.status === 'FAILED' ? '‚ùå' : 
                        transaction.status === 'PROCESSING' ? '‚è≥' : '‚ùì';
      
      message += `${statusIcon} Status: ${transaction.status}\n`;

      if (transaction.hesdaTrxId) {
        message += `üîó Hesda ID: ${transaction.hesdaTrxId}\n`;
        
        // Cek status di API Hesda
        message += `\nüîÑ Mengecek status di sistem Hesda...`;
        await sock.sendMessage(sender, { text: message });

        const statusResult = await hesdaApi.checkTransactionStatus(transaction.hesdaTrxId, sender);
        
        if (statusResult.success) {
          const hesdaStatus = statusResult.data.status;
          
          message += `\n\nüì° *Status di Hesda:*\n`;
          message += `${statusIcon} Status: ${hesdaStatus}\n`;
          message += `üì¶ Paket: ${statusResult.data.package_name}\n`;
          message += `üìû Nomor: ${statusResult.data.no_hp}\n`;
          
          if (hesdaStatus !== transaction.status) {
            // Update status di database
            await db.updateTransactionStatus(trxId, hesdaStatus);
            
            message += `\nüîÑ *Status Updated:*\n`;
            message += `Database: ${transaction.status} ‚Üí ${hesdaStatus}\n`;
            
            logAdminAction('UPDATE_TX_STATUS', sender, trxId, `${transaction.status} ‚Üí ${hesdaStatus}`);
          } else {
            message += `\n‚úÖ Status sudah sinkron dengan database`;
          }
        } else {
          message += `\n\n‚ùå Gagal cek status di Hesda:\n${statusResult.message}`;
        }
      } else {
        message += `\n‚ö†Ô∏è Tidak ada Hesda Transaction ID`;
      }

      await sock.sendMessage(sender, { text: message });
      logAdminAction('CHECK_TX_STATUS', sender, trxId);
      
    } catch (error) {
      logSystemError(error, 'Checking transaction status');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal cek status transaksi.' 
      });
    }
  }

  // Get low saldo users (users dengan saldo < threshold)
  static async getLowSaldoUsers(sock, sender, threshold = 5000) {
    try {
      const users = await db.getAllUsers();
      const lowSaldoUsers = Object.values(users)
        .filter(user => (user.saldo || 0) < threshold && (user.saldo || 0) > 0)
        .sort((a, b) => (a.saldo || 0) - (b.saldo || 0));

      if (lowSaldoUsers.length === 0) {
        await sock.sendMessage(sender, { 
          text: `üìä *Saldo Rendah*\n\nTidak ada user dengan saldo < Rp.${threshold.toLocaleString('id-ID')}` 
        });
        return;
      }

      let message = `‚ö†Ô∏è *User Saldo Rendah (<Rp.${threshold.toLocaleString('id-ID')})*\n\n`;
      
      lowSaldoUsers.slice(0, 15).forEach((user, index) => {
        const phone = user.phoneNumber.replace('62', '+62 ').replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
        const saldo = user.saldo || 0;
        
        message += `${index + 1}. ${phone}\n`;
        message += `   üí∞ Rp. ${saldo.toLocaleString('id-ID')}\n\n`;
      });

      if (lowSaldoUsers.length > 15) {
        message += `... dan ${lowSaldoUsers.length - 15} user lainnya`;
      }

      await sock.sendMessage(sender, { text: message });
      logAdminAction('VIEW_LOW_SALDO_USERS', sender, '', `Threshold: ${threshold}, Count: ${lowSaldoUsers.length}`);
      
    } catch (error) {
      logSystemError(error, 'Getting low saldo users');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal mengambil data user saldo rendah.' 
      });
    }
  }

  // Export user data untuk backup/analysis
  static async exportUserData(sock, sender, format = 'summary') {
    try {
      const users = await db.getAllUsers();
      const userCount = Object.keys(users).length;
      
      if (userCount === 0) {
        await sock.sendMessage(sender, { 
          text: 'üìä Tidak ada data user untuk di-export.' 
        });
        return;
      }

      let message = `üìä *Export Data User*\n`;
      message += `üìÖ ${new Date().toLocaleString('id-ID')}\n`;
      message += `üë• Total: ${userCount} user\n\n`;

      if (format === 'summary') {
        // Summary export
        const totalSaldo = Object.values(users).reduce((sum, user) => sum + (user.saldo || 0), 0);
        const avgSaldo = Math.round(totalSaldo / userCount);
        const activeUsers = Object.values(users).filter(user => {
          const lastActivity = new Date(user.lastActivity || user.registeredAt);
          const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
          return lastActivity > sevenDaysAgo;
        }).length;

        message += `üí∞ *Financial Summary:*\n`;
        message += `‚Ä¢ Total saldo: Rp.${totalSaldo.toLocaleString('id-ID')}\n`;
        message += `‚Ä¢ Rata-rata: Rp.${avgSaldo.toLocaleString('id-ID')}\n`;
        message += `‚Ä¢ User aktif: ${activeUsers}/${userCount}\n\n`;

        // Saldo distribution
        const saldoRanges = {
          '0': 0,
          '1-10k': 0,
          '10k-50k': 0,
          '50k-100k': 0,
          '100k+': 0
        };

        Object.values(users).forEach(user => {
          const saldo = user.saldo || 0;
          if (saldo === 0) saldoRanges['0']++;
          else if (saldo < 10000) saldoRanges['1-10k']++;
          else if (saldo < 50000) saldoRanges['10k-50k']++;
          else if (saldo < 100000) saldoRanges['50k-100k']++;
          else saldoRanges['100k+']++;
        });

        message += `üìä *Distribusi Saldo:*\n`;
        Object.entries(saldoRanges).forEach(([range, count]) => {
          const percentage = Math.round((count / userCount) * 100);
          message += `‚Ä¢ ${range}: ${count} (${percentage}%)\n`;
        });

      } else if (format === 'detailed') {
        // Detailed export (limit to 20 users untuk tidak spam)
        message += `üìã *Detail User (Top 20):*\n\n`;
        
        const sortedUsers = Object.values(users)
          .sort((a, b) => (b.saldo || 0) - (a.saldo || 0))
          .slice(0, 20);

        sortedUsers.forEach((user, index) => {
          const phone = user.phoneNumber.replace('62', '+62 ').replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
          const saldo = user.saldo || 0;
          const totalTx = user.totalTransaksi || 0;
          const registered = new Date(user.registeredAt).toLocaleDateString('id-ID');
          
          message += `${index + 1}. ${phone}\n`;
          message += `   üí∞ Rp.${saldo.toLocaleString('id-ID')}\n`;
          message += `   üìä ${totalTx}x transaksi\n`;
          message += `   üìÖ ${registered}\n\n`;
        });

        if (userCount > 20) {
          message += `... dan ${userCount - 20} user lainnya\n\n`;
        }
      }

      message += `üíæ *Backup Info:*\n`;
      message += `‚Ä¢ Database: ${process.env.DATABASE_TYPE || 'JSON'}\n`;
      message += `‚Ä¢ Untuk backup lengkap: npm run backup-data\n`;
      message += `‚Ä¢ Untuk export CSV: hubungi developer`;

      await sock.sendMessage(sender, { text: message });
      logAdminAction('EXPORT_USER_DATA', sender, '', `Format: ${format}, Users: ${userCount}`);
      
    } catch (error) {
      logSystemError(error, 'Exporting user data');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal export data user.' 
      });
    }
  }

  // System maintenance commands
  static async performMaintenance(sock, sender, action) {
    try {
      await sock.sendMessage(sender, { 
        text: `üîß Memulai maintenance: ${action}...` 
      });

      switch (action.toLowerCase()) {
        case 'cleanup':
          await this.cleanupOldData(sock, sender);
          break;
          
        case 'backup':
          await this.createBackup(sock, sender);
          break;
          
        case 'optimize':
          await this.optimizeDatabase(sock, sender);
          break;
          
        default:
          await sock.sendMessage(sender, { 
            text: `‚ùå *Action tidak dikenal*\n\nAction tersedia:\n‚Ä¢ cleanup - Bersihkan data lama\n‚Ä¢ backup - Backup database\n‚Ä¢ optimize - Optimasi database` 
          });
          return;
      }

      logAdminAction('MAINTENANCE', sender, action);
      
    } catch (error) {
      logSystemError(error, `Maintenance: ${action}`);
      await sock.sendMessage(sender, { 
        text: `‚ùå Gagal menjalankan maintenance: ${action}` 
      });
    }
  }

  // Helper: Cleanup old data
  static async cleanupOldData(sock, sender) {
    try {
      let cleanupCount = 0;
      
      // Cleanup old sessions (>30 days)
      const sessions = await db.readFile('./data/sessions.json');
      const cutoffDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      
      for (const [phone, session] of Object.entries(sessions)) {
        const lastUsed = new Date(session.lastUsed || session.createdAt);
        if (lastUsed < cutoffDate) {
          delete sessions[phone];
          cleanupCount++;
        }
      }
      
      await db.writeFile('./data/sessions.json', sessions);
      
      // Archive old transactions (>90 days)
      const transactions = await db.readFile('./data/transactions.json');
      const archiveDate = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
      const activeTransactions = {};
      const archivedTransactions = {};
      let archivedCount = 0;
      
      for (const [trxId, tx] of Object.entries(transactions)) {
        const txDate = new Date(tx.createdAt);
        if (txDate > archiveDate) {
          activeTransactions[trxId] = tx;
        } else {
          archivedTransactions[trxId] = tx;
          archivedCount++;
        }
      }
      
      if (archivedCount > 0) {
        await db.writeFile('./data/transactions.json', activeTransactions);
        await db.writeFile(`./backup/transactions_archive_${Date.now()}.json`, archivedTransactions);
      }

      const message = `‚úÖ *Cleanup Selesai*\n\nüìä **Hasil:**\n‚Ä¢ Session dihapus: ${cleanupCount}\n‚Ä¢ Transaksi diarsip: ${archivedCount}\n\nüìÖ ${new Date().toLocaleString('id-ID')}`;
      
      await sock.sendMessage(sender, { text: message });
      
    } catch (error) {
      logSystemError(error, 'Cleanup old data');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal cleanup data lama.' 
      });
    }
  }

  // Helper: Create backup
  static async createBackup(sock, sender) {
    try {
      await db.backup();
      
      const message = `‚úÖ *Backup Selesai*\n\nüíæ Database berhasil di-backup\nüìÅ Lokasi: ./backup/\nüìÖ ${new Date().toLocaleString('id-ID')}\n\nüí° Backup otomatis jalan setiap hari jam 02:00`;
      
      await sock.sendMessage(sender, { text: message });
      
    } catch (error) {
      logSystemError(error, 'Creating backup');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal membuat backup.' 
      });
    }
  }

  // Helper: Optimize database
  static async optimizeDatabase(sock, sender) {
    try {
      let optimizeInfo = '';
      
      if (process.env.DATABASE_TYPE === 'sqlite' && db.adapter && db.adapter.vacuum) {
        db.adapter.vacuum();
        optimizeInfo = '‚Ä¢ SQLite database di-vacuum\n';
      } else {
        optimizeInfo = '‚Ä¢ JSON database (tidak perlu optimasi)\n';
      }
      
      // Force garbage collection
      if (global.gc) {
        global.gc();
        optimizeInfo += '‚Ä¢ Memory garbage collection\n';
      }
      
      const memUsage = process.memoryUsage();
      const heapUsedMB = Math.round(memUsage.heapUsed / 1024 / 1024);
      
      const message = `‚úÖ *Optimasi Selesai*\n\nüîß **Yang dilakukan:**\n${optimizeInfo}\nüìä **Memory usage:** ${heapUsedMB}MB\nüìÖ ${new Date().toLocaleString('id-ID')}`;
      
      await sock.sendMessage(sender, { text: message });
      
    } catch (error) {
      logSystemError(error, 'Optimizing database');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal optimasi database.' 
      });
    }
  }

  // Advanced analytics
  static async getAdvancedAnalytics(sock, sender, period = '30d') {
    try {
      await sock.sendMessage(sender, { 
        text: `üìà Menganalisis data ${period}...` 
      });

      const transactions = await db.readFile('./data/transactions.json');
      const allTransactions = Object.values(transactions);
      
      // Determine date range
      let startDate;
      switch (period) {
        case '7d':
          startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
          break;
        case '30d':
          startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
          break;
        case '90d':
          startDate = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
          break;
        default:
          startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      }

      const periodTransactions = allTransactions.filter(tx => 
        new Date(tx.createdAt) > startDate
      );

      if (periodTransactions.length === 0) {
        await sock.sendMessage(sender, { 
          text: `üìà *Analytics ${period}*\n\nTidak ada transaksi dalam periode ini.` 
        });
        return;
      }

      // Analysis
      const successTx = periodTransactions.filter(tx => tx.status === 'SUCCESS');
      const failedTx = periodTransactions.filter(tx => tx.status === 'FAILED');
      
      const totalRevenue = successTx.reduce((sum, tx) => sum + (tx.amount || 0), 0);
      const totalProfit = successTx.reduce((sum, tx) => sum + ((tx.amount || 0) - (tx.cost || 0)), 0);
      
      const successRate = Math.round((successTx.length / periodTransactions.length) * 100);
      const avgTransactionValue = successTx.length > 0 ? Math.round(totalRevenue / successTx.length) : 0;

      // Daily breakdown untuk period 7d atau 30d
      const dailyStats = {};
      const days = period === '7d' ? 7 : period === '30d' ? 30 : 90;
      
      for (let i = 0; i < days; i++) {
        const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000);
        const dateStr = date.toISOString().split('T')[0];
        dailyStats[dateStr] = { count: 0, revenue: 0 };
      }

      successTx.forEach(tx => {
        const date = tx.createdAt.split('T')[0];
        if (dailyStats[date]) {
          dailyStats[date].count++;
          dailyStats[date].revenue += tx.amount || 0;
        }
      });

      const bestDay = Object.entries(dailyStats)
        .sort(([,a], [,b]) => b.revenue - a.revenue)[0];

      // Package analysis
      const packageStats = {};
      successTx.forEach(tx => {
        const pkg = tx.packageName || 'Unknown';
        if (!packageStats[pkg]) {
          packageStats[pkg] = { count: 0, revenue: 0 };
        }
        packageStats[pkg].count++;
        packageStats[pkg].revenue += tx.amount || 0;
      });

      const topPackage = Object.entries(packageStats)
        .sort(([,a], [,b]) => b.count - a.count)[0];

      // User analysis
      const userStats = {};
      successTx.forEach(tx => {
        const user = tx.phoneNumber;
        userStats[user] = (userStats[user] || 0) + 1;
      });

      const topUser = Object.entries(userStats)
        .sort(([,a], [,b]) => b - a)[0];

      const uniqueUsers = Object.keys(userStats).length;

      let message = `üìà *Advanced Analytics (${period})*\n\n`;
      
      message += `üìä **Overview:**\n`;
      message += `‚Ä¢ Total transaksi: ${periodTransactions.length}\n`;
      message += `‚Ä¢ Sukses: ${successTx.length} (${successRate}%)\n`;
      message += `‚Ä¢ Gagal: ${failedTx.length}\n`;
      message += `‚Ä¢ Unique users: ${uniqueUsers}\n\n`;
      
      message += `üí∞ **Financial:**\n`;
      message += `‚Ä¢ Revenue: Rp.${totalRevenue.toLocaleString('id-ID')}\n`;
      message += `‚Ä¢ Profit: Rp.${totalProfit.toLocaleString('id-ID')}\n`;
      message += `‚Ä¢ Avg per tx: Rp.${avgTransactionValue.toLocaleString('id-ID')}\n\n`;

      if (bestDay) {
        const bestDate = new Date(bestDay[0]).toLocaleDateString('id-ID');
        message += `üî• **Best Day:**\n`;
        message += `‚Ä¢ Tanggal: ${bestDate}\n`;
        message += `‚Ä¢ Transaksi: ${bestDay[1].count}\n`;
        message += `‚Ä¢ Revenue: Rp.${bestDay[1].revenue.toLocaleString('id-ID')}\n\n`;
      }

      if (topPackage) {
        message += `üì¶ **Top Package:**\n`;
        message += `‚Ä¢ ${topPackage[0]}\n`;
        message += `‚Ä¢ Count: ${topPackage[1].count}x\n`;
        message += `‚Ä¢ Revenue: Rp.${topPackage[1].revenue.toLocaleString('id-ID')}\n\n`;
      }

      if (topUser) {
        const topUserPhone = topUser[0].replace('62', '+62 ').replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
        message += `üëë **Top User:**\n`;
        message += `‚Ä¢ ${topUserPhone}\n`;
        message += `‚Ä¢ Transaksi: ${topUser[1]}x\n\n`;
      }

      message += `üìÖ Generated: ${new Date().toLocaleString('id-ID')}`;

      await sock.sendMessage(sender, { text: message });
      logAdminAction('VIEW_ANALYTICS', sender, '', `Period: ${period}`);
      
    } catch (error) {
      logSystemError(error, 'Getting advanced analytics');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal mengambil analytics.' 
      });
    }
  }

  // Get failed transactions with details
  static async getFailedTransactions(sock, sender) {
    try {
      const transactions = await db.readFile('./data/transactions.json');
      const failedTx = Object.values(transactions)
        .filter(tx => tx.status === 'FAILED')
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      if (failedTx.length === 0) {
        await sock.sendMessage(sender, { 
          text: '‚úÖ *Tidak ada transaksi gagal*\n\nSemua transaksi berhasil diproses.' 
        });
        return;
      }

      let message = `‚ùå *Transaksi Gagal (${failedTx.length})*\n\n`;
      
      // Group by error type
      const errorTypes = {};
      failedTx.forEach(tx => {
        const error = tx.errorMessage || 'Unknown Error';
        errorTypes[error] = (errorTypes[error] || 0) + 1;
      });

      message += `üìä **Error Types:**\n`;
      Object.entries(errorTypes)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 5)
        .forEach(([error, count]) => {
          message += `‚Ä¢ ${error}: ${count}x\n`;
        });

      message += `\nüìã **Recent Failed (Top 10):**\n\n`;
      
      failedTx.slice(0, 10).forEach((tx, index) => {
        const time = new Date(tx.createdAt).toLocaleDateString('id-ID');
        
        message += `${index + 1}. ${tx.trxId}\n`;
        message += `   üìû ${tx.targetNumber}\n`;
        message += `   üì¶ ${tx.packageName}\n`;
        message += `   üí∞ Rp.${tx.amount.toLocaleString('id-ID')}\n`;
        message += `   üìÖ ${time}\n`;
        if (tx.errorMessage) {
          message += `   ‚ùå ${tx.errorMessage}\n`;
        }
        message += '\n';
      });

      if (failedTx.length > 10) {
        message += `... dan ${failedTx.length - 10} transaksi gagal lainnya`;
      }

      await sock.sendMessage(sender, { text: message });
      logAdminAction('VIEW_FAILED_TX', sender, '', `Count: ${failedTx.length}`);
      
    } catch (error) {
      logSystemError(error, 'Getting failed transactions');
      await sock.sendMessage(sender, { 
        text: '‚ùå Gagal mengambil transaksi gagal.' 
      });
    }
  }
}

module.exports = AdminCommands;